#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
# Modifications Copyright 2022 The DAPHNE Consortium
#
#-------------------------------------------------------------

# Simple iterative PageRank implementation

# read the input matrix
G = readMatrix($G);

# maximum number of iterations
maxi = as.si64($maxi);

# error for convergence
e = as.f64($e);

# verbosity toggle
verbose = $verbose;

# get the number for rows
n = nrow(G);

# FIXME: we could skip the transpose here, since the matmul kernel has knobs to
# transpose either argument, but that doesn't seem to exposed to the DSL atm
# afaict
# FIXME: we could also skip the replace if there's a way to filter the non-zero
# sums and apply the pow only to these.
# note that the pow is sort of a workaround, since we only support EwMul atm, not Div,
# but we would have the same issue with the zero elements in that case as well.
M = replace(t(G * pow(sum(G, 0), -1)), nan, 0);

# uncomment the following lines to use a damping factor
# note that this will probably force M to become dense
df = as.f64($df); # damping factor
M = df * M + (1 - df) / n;

# compute the initial PageRank vector, with a uniform initial probability distribution
P = M @ fill(1.0 / n, n, 1);

iter = 0;
delta = inf;
while(as.si64(iter < maxi) && as.si64(delta > e)) {
	# compute the next PageRank vector
	N = M @ P;

	# L2-norm delta
	delta = sqrt(sum(pow((N - P), 2)));

	P = N;

	if (verbose) {
		print("pagerank: iter=", 0, 0); print(iter+"e="+delta);
	}

	iter = iter + 1;
}

print("pagerank: finished after ", 0, 0);
print(iter+" iterations, e="+delta);
print(P);
